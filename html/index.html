<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
        canvas, #config {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            image-rendering: pixelated;
        }
        #config {
            width: 50vw;
            background-color: rgb(0, 0, 0, .75);
            font-family: monospace;
            color: white;
            overflow-y: scroll;
        }
        #config h1 {
            font-size: 8vmin;
        }
        #config h2 {
            font-size: 4vmin;
        }
        #config h3 {
            font-size: 2vmin;
        }
        #config input:not(input[type=checkbox]) {
            width: 50vmin;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="100" height="200">
    </canvas>
    <div id="config" hidden>
        <h1>
            Config
        </h1>
        <div>
            <h2>
            Source 
            </h2>
            <div>
                <input id="config_source" type="text" value="http://dl5.webmfiles.org/elephants-dream.webm">
            </div>
            <div>
                <button onclick="sourceFeed()">Source Feed</button>
                <button onclick="cameraFeed()">Camera Feed</button>
            </div>
        </div>
        <div>
            <h2>
                Contrast & Brightness
            </h2>
            <div>
                <h3>
                    Contrast
                </h3>
                <input id="config_contrast" type="range" value="1" min="-5" max="5" step=".01" onchange="configRefresh()">
            </div>
            <div>
                <h3>
                    Brightness
                </h3>
                <input id="config_brightness" type="range" value="0" min="-5" max="5" step=".01" onchange="configRefresh()">
            </div>
        </div>
        <div>
            <h2>
                Dimension
            </h2>
            <div>
                <h3>
                    Width
                </h3>
                <input id="config_dimension_width" type="number" value="100" onchange="configRefresh()">
            </div>
            <div>
                <h3>
                    Height
                </h3>
                <input id="config_dimension_height" type="number" value="100" onchange="configRefresh()">
            </div>
        </div>
        <div>
            <h2>
                Flip
            </h2>
            <div>
                <input id="config_flip_horizontal" type="checkbox" onchange="configRefresh()" checked>
                <label for="config_flip_horizontal">Horizontal</label>
            </div>
            <div>
                <input id="config_flip_vertical" type="checkbox" onchange="configRefresh()">
                <label for="config_flip_vertical">Vertical</label>
            </div>
        </div>
    </div>
    <script>
        'use strict'
        //#region WebGL
        function loadShader(context, type, source) {
            const shader = context.createShader(type)
            context.shaderSource(shader, source)
            context.compileShader(shader)
            if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
                console.error(context.getShaderInfoLog(shader))
                context.deleteShader(shader)
                return null
            }
            return shader
        }
        function initShaderProgram(context, vsSource, fsSource) {
            const vertexShader = loadShader(context, context.VERTEX_SHADER, vsSource)
            const fragmentShader = loadShader(context, context.FRAGMENT_SHADER, fsSource)
            const shaderProgram = context.createProgram()
            context.attachShader(shaderProgram, vertexShader)
            context.attachShader(shaderProgram, fragmentShader)
            context.linkProgram(shaderProgram)
            if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
                console.error(context.getProgramInfoLog(shaderProgram))
                return null
            }
            return shaderProgram
        }
        function initTexture(context) {
            const texture = context.createTexture()
            context.activeTexture(context.TEXTURE0)
            context.bindTexture(context.TEXTURE_2D, texture)
            context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE, null)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST)
            return texture
        }
        function updateTextureSource(context, texture, src) {
            context.activeTexture(context.TEXTURE0)
            context.bindTexture(context.TEXTURE_2D, texture)
            context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, src)
        }
        function updateTextureSize(context, texture, width, height) {
            context.activeTexture(context.TEXTURE0)
            context.bindTexture(context.TEXTURE_2D, texture)
            context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, width, height, 0, context.RGBA, context.UNSIGNED_BYTE, null)
        }
        function createFrameBuffer(context) {
            const frameBuffer   = context.createFramebuffer()
            const texture       = initTexture(context)
            context.bindFramebuffer(context.FRAMEBUFFER, frameBuffer)
            context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.TEXTURE_2D, texture, 0)
            return {
                buffer: frameBuffer,
                texture: texture
            }
        }
        const screen = [
            -1, -1,
            1, -1,
            -1,  1,
            -1, 1,
            1, -1,
            1, 1,
        ]
        const screenUV = [
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1,
        ]
        let screenBuffer
        let screenUVBuffer
        function initBuffers(context) {
            screenBuffer = context.createBuffer()
            screenUVBuffer = context.createBuffer()
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(screen), context.STATIC_DRAW)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(screenUV), context.STATIC_DRAW)
        }
        //#endregion
        //#region Intensity Shader
        const shaderSourceIntensityVertex =
        `#version 300 es
        in vec2 aVertexPosition;
        in vec2 aTextureCoord;
        uniform ivec2 uFlip;
        out vec2 vTextureCoord;
        void main() {
            gl_Position     = vec4(
                uFlip.x != 0 ? aVertexPosition.x : 0.0 - aVertexPosition.x, 
                uFlip.y != 0 ? aVertexPosition.y : 0.0 - aVertexPosition.y, 
                0.0, 
                1.0);
            vTextureCoord   = aTextureCoord;
        }
        `
        const shaderSourceIntensityFragment =
        `#version 300 es
        precision lowp float;
        in vec2 vTextureCoord;
        uniform vec2 uRange;
        uniform sampler2D uSampler;
        out vec4 outColor;
        void main() {
            vec4 color      = texture(uSampler, vTextureCoord);
            float intensity = (color.r + color.g + color.b) / 3.0;
            intensity       = (uRange.x * (intensity - 0.5)) + 0.5 + uRange.y;
            outColor        = vec4(intensity, intensity, intensity, 1.0);
        }
        `
        function createIntensityShader(context, texture) {
            const shaderProgram     = initShaderProgram(context, shaderSourceIntensityVertex, shaderSourceIntensityFragment)
            const aVertexPosition   = context.getAttribLocation(shaderProgram, 'aVertexPosition')
            const aTextureCoord     = context.getAttribLocation(shaderProgram, 'aTextureCoord')
            const uFlip             = context.getUniformLocation(shaderProgram, 'uFlip')
            const uRange            = context.getUniformLocation(shaderProgram, 'uRange')
            const uSampler          = context.getUniformLocation(shaderProgram, 'uSampler')
            context.useProgram(shaderProgram)
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.vertexAttribPointer(aVertexPosition, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aVertexPosition)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.vertexAttribPointer(aTextureCoord, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aTextureCoord)
            context.uniform1i(uSampler, 0)
            return {
                program: shaderProgram,
                uniform: {
                    flip: uFlip,
                    range: uRange,
                },
                texture: texture,
                render(context, flip, range) {
                    context.useProgram(this.program)
                    context.activeTexture(context.TEXTURE0)
                    context.bindTexture(context.TEXTURE_2D, this.texture)
                    context.uniform2iv(this.uniform.flip, flip)
                    context.uniform2fv(this.uniform.range, range)
                    context.drawArrays(context.TRIANGLES, 0, 6)
                }
            }
        }
        //#endregion
        //#region Gameboy Shader
        const shaderSourceGameboyVertex =
        `#version 300 es
        in vec2 aVertexPosition;
        in vec2 aTextureCoord;
        out vec2 vTextureCoord;
        void main() {
            gl_Position     = vec4(aVertexPosition.x, aVertexPosition.y, 0.0, 1.0);
            vTextureCoord   = aTextureCoord;
        }
        `
        const shaderSourceGameboyFragment =
        `#version 300 es
        precision lowp float;
        in vec2 vTextureCoord;
        uniform sampler2D uSampler;
        out vec4 outColor;
        void main() {
            bool evenColumn     = (mod(floor(gl_FragCoord.x), 2.0) == 0.0);
            bool evenRow        = (mod(floor(gl_FragCoord.y), 2.0) == 0.0);
            vec4 color          = texture(uSampler, vTextureCoord);
            float pixel         = color.r * 4.0;
            float decimal       = mod(pixel, 1.0);
            if (decimal > 0.25 && .75 < decimal) {
                if (evenColumn) {
                    if (evenRow) {
                        pixel = ceil(pixel);
                    } else {
                        pixel = floor(pixel);
                    }
                } else {
                    if (evenRow) {
                        pixel = floor(pixel);
                    } else {
                        pixel = ceil(pixel);
                    }
                }
            } else {
                pixel = floor(pixel + 0.5);
            }
            pixel /= 4.0;
            
            outColor = vec4(pixel, pixel + .05, pixel, 1.0);
        }
        `
        function createGameboyShader(context, texture) {
            const shaderProgram     = initShaderProgram(context, shaderSourceGameboyVertex, shaderSourceGameboyFragment)
            const aVertexPosition   = context.getAttribLocation(shaderProgram, 'aVertexPosition')
            const aTextureCoord     = context.getAttribLocation(shaderProgram, 'aTextureCoord')
            const uSampler          = context.getUniformLocation(shaderProgram, 'uSampler')
            context.useProgram(shaderProgram)
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.vertexAttribPointer(aVertexPosition, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aVertexPosition)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.vertexAttribPointer(aTextureCoord, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aTextureCoord)
            context.uniform1i(uSampler, 0)
            return {
                program: shaderProgram,
                texture: texture,
                render(context) {
                    context.useProgram(this.program)
                    context.activeTexture(context.TEXTURE0)
                    context.bindTexture(context.TEXTURE_2D, this.texture)
                    context.drawArrays(context.TRIANGLES, 0, 6)
                }
            }
        }
        //#endregion
        //#region Dither Shader
        const shaderSourceDitherVertex =
        `#version 300 es
        in vec2 aVertexPosition;
        in vec2 aTextureCoord;
        out vec2 vTextureCoord;
        void main() {
            gl_Position     = vec4(aVertexPosition.x, aVertexPosition.y, 0.0, 1.0);
            vTextureCoord   = aTextureCoord;
        }
        `
        const shaderSourceDitherFragment =
        `#version 300 es
        precision lowp float;
        const float DIMENSION  = 2.0;
        const int MATRIX_SIZE  = 4;
        in vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform float uFilter[MATRIX_SIZE];
        out vec4 outColor;
        void main() {
            vec4 color     = texture(uSampler, vTextureCoord);
            if (color.r > uFilter[int(mod(gl_FragCoord.x, DIMENSION) + (mod(gl_FragCoord.y, DIMENSION) * DIMENSION))]) {
                outColor    = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
                outColor    = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
        `
        function createDitherShader(context, texture) {
            const shaderProgram     = initShaderProgram(context, shaderSourceDitherVertex, shaderSourceDitherFragment)
            const aVertexPosition   = context.getAttribLocation(shaderProgram, 'aVertexPosition')
            const aTextureCoord     = context.getAttribLocation(shaderProgram, 'aTextureCoord')
            const uSampler          = context.getUniformLocation(shaderProgram, 'uSampler')
            const uFilter           = context.getUniformLocation(shaderProgram, 'uFilter')
            context.useProgram(shaderProgram)
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.vertexAttribPointer(aVertexPosition, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aVertexPosition)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.vertexAttribPointer( aTextureCoord, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aTextureCoord)
            context.uniform1i(uSampler, 0)
            return {
                program: shaderProgram,
                uniform: {
                    filter: uFilter
                },
                texture: texture,
                render(context, flip, range) {
                    context.useProgram(this.program)
                    context.activeTexture(context.TEXTURE0)
                    context.bindTexture(context.TEXTURE_2D, this.texture)
                    context.uniform1fv(this.uniform.filter, [0, .5, .75, .25])
                    context.drawArrays(context.TRIANGLES, 0, 6)
                }
            }
        }
        //#endregion
        const electron              = require('electron')
        const print                 = electron.remote.require('./index.js').print
        
        const video                 = document.createElement('video')
        const canvas                = document.getElementById('canvas')
        const context               = canvas.getContext('webgl2')
        const config                = document.getElementById('config')
        const configSource          = document.getElementById('config_source')
        const configContrast        = document.getElementById('config_contrast')
        const configBrightness      = document.getElementById('config_brightness')
        const configDimensionWidth  = document.getElementById('config_dimension_width')
        const configDimensionHeight = document.getElementById('config_dimension_height')
        const configFlipHorizontal  = document.getElementById('config_flip_horizontal')
        const configFlipVertical    = document.getElementById('config_flip_vertical')

        video.loop = true
        video.muted = true
        video.autoplay = true

        let contrast
        let brightness
        let flipHorizontal
        let flipVertical

        initBuffers(context)
        const texture           = initTexture(context)
        const shaderIntensity   = createIntensityShader(context, texture)
        const bufferIntensity   = createFrameBuffer(context)
        const shaderGameboy     = createGameboyShader(context, bufferIntensity.texture)
        const shaderDither      = createDitherShader(context, bufferIntensity.texture)

        function cameraFeed() {
            video.toggleAttribute('src', false)
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
            .then(stream=>{
                video.srcObject = stream
                video.play()
            })
            .catch(err=>console.error(err))
        }

        function sourceFeed() {
            video.src = configSource.value
            video.play()
        }

        function configRefresh() {
            contrast        = configContrast.value
            brightness      = configBrightness.value
            flipHorizontal  = configFlipHorizontal.checked?1:0
            flipVertical    = configFlipVertical.checked?1:0
            canvas.width    = configDimensionWidth.value
            canvas.height   = configDimensionHeight.value
            updateTextureSize(context, bufferIntensity.texture, context.canvas.width, context.canvas.height)
        }
        configRefresh()

        function draw(timestamp) {
            updateTextureSource(context, texture, video)
            context.clearColor(1.0, 0.0, 0.0, 1.0)
            context.clear(context.COLOR_BUFFER_BIT | context.COLOR_BUFFER_BIT)
            context.viewport(0, 0, context.canvas.width, context.canvas.height)
            context.bindFramebuffer(context.FRAMEBUFFER, bufferIntensity.buffer)
            shaderIntensity.render(context, [flipHorizontal, flipVertical], [contrast, brightness])
            context.bindFramebuffer(context.FRAMEBUFFER, null)
            if (isTakingPicture) {
                shaderDither.render(context)
                takePicture()
                isTakingPicture = false
            }
            shaderGameboy.render(context)
            requestAnimationFrame(draw)
        }
        
        function takePicture() {
            canvas.toBlob(blob=>{
                blob
                .arrayBuffer()
                .then(buffer=>print(buffer))
            }, 'image/png')
        }
        
        let isTakingPicture = false
        window.addEventListener('keyup',e=>{
            switch (e.key) {
                case 'q':
                    config.toggleAttribute('hidden')
                break
                case 'x':
                    window.close()
                break
                case ' ':
                    if (!isTakingPicture) isTakingPicture = true
                break
            }
        }, true)

        requestAnimationFrame(draw)
    </script>
</body>
</html>
