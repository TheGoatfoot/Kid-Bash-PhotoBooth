<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
        canvas, #config {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            image-rendering: pixelated;
        }
        #config {
            width: 50vw;
            background-color: rgb(0, 0, 0, .75);
            font-family: monospace;
            color: white;
            overflow-y: scroll;
        }
        #config h1 {
            font-size: 8vmin;
        }
        #config h2 {
            font-size: 4vmin;
        }
        #config h3 {
            font-size: 2vmin;
        }
        #config input:not(input[type=checkbox]) {
            width: 50vmin;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="100" height="200">
    </canvas>
    <div id="config" hidden>
        <h1>
            Config
        </h1>
        <div>
            <h2>
            Source 
            </h2>
            <div>
                <input id="config_source" type="text" value="http://dl5.webmfiles.org/elephants-dream.webm">
            </div>
            <div>
                <button onclick="sourceFeed()">Source Feed</button>
                <button onclick="cameraFeed()">Camera Feed</button>
            </div>
        </div>
        <div>
            <h2>
                Contrast & Brightness
            </h2>
            <div>
                <h3>
                    Contrast
                </h3>
                <input id="config_contrast" type="range" value="1" min="-5" max="5" step=".01" onchange="configRefresh()">
            </div>
            <div>
                <h3>
                    Brightness
                </h3>
                <input id="config_brightness" type="range" value="0" min="-5" max="5" step=".01" onchange="configRefresh()">
            </div>
        </div>
        <div>
            <h2>
                Dimension
            </h2>
            <div>
                <h3>
                    Width
                </h3>
                <input id="config_dimension_width" type="number" value="100" onchange="configRefresh()">
            </div>
            <div>
                <h3>
                    Height
                </h3>
                <input id="config_dimension_height" type="number" value="100" onchange="configRefresh()">
            </div>
        </div>
        <div>
            <h2>
                Flip
            </h2>
            <div>
                <input id="config_flip_horizontal" type="checkbox" onchange="configRefresh()" checked>
                <label for="config_flip_horizontal">Horizontal</label>
            </div>
            <div>
                <input id="config_flip_vertical" type="checkbox" onchange="configRefresh()">
                <label for="config_flip_vertical">Vertical</label>
            </div>
        </div>
    </div>
    <script>
        function loadShader(context, type, source) {
            const shader = context.createShader(type)
            context.shaderSource(shader, source)
            context.compileShader(shader)
            if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
                console.error(context.getShaderInfoLog(shader))
                context.deleteShader(shader)
                return null
            }
            return shader
        }
        function initShaderProgram(context, vsSource, fsSource) {
            const vertexShader = loadShader(context, context.VERTEX_SHADER, vsSource)
            const fragmentShader = loadShader(context, context.FRAGMENT_SHADER, fsSource)
            const shaderProgram = context.createProgram()
            context.attachShader(shaderProgram, vertexShader)
            context.attachShader(shaderProgram, fragmentShader)
            context.linkProgram(shaderProgram)
            if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
                console.error(context.getProgramInfoLog(shaderProgram))
                return null
            }
            return shaderProgram
        }
        function initTexture(gl, src) {
            const texture = context.createTexture()
            context.bindTexture(context.TEXTURE_2D, texture)
            context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE, src)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE)
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE)
            return texture
        }
        function updateTexture(context, texture, src) {
            context.bindTexture(context.TEXTURE_2D, texture)
            context.texImage2D( context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, src)
        }
        const screen = [
            -1, -1,
            1, -1,
            -1,  1,
            -1, 1,
            1, -1,
            1, 1,
        ]
        const screenUV = [
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1,
        ]
        let screenBuffer
        let screenUVBuffer
        function initBuffers(context) {
            screenBuffer = context.createBuffer()
            screenUVBuffer = context.createBuffer()
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(screen), context.STATIC_DRAW)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.bufferData(context.ARRAY_BUFFER, new Float32Array(screenUV), context.STATIC_DRAW)
        }
    </script>
    <script>
        const shaderSourceIntensityVertex =
        `
        attribute lowp vec2 aVertexPosition;
        attribute lowp vec2 aTextureCoord;
        uniform lowp ivec2 uFlip;
        varying lowp vec2 vTextureCoord;
        void main() {
            gl_Position     = vec4(
                uFlip.x != 0 ? aVertexPosition.x : 0.0 - aVertexPosition.x, 
                uFlip.y != 0 ? aVertexPosition.y : 0.0 - aVertexPosition.y, 
                0.0, 
                1.0);
            vTextureCoord   = aTextureCoord;
        }
        `
        const shaderSourceIntensityFragment =
        `
        varying lowp vec2 vTextureCoord;
        uniform lowp vec2 uRange;
        uniform sampler2D uSampler;
        void main() {
            lowp vec4 color         = texture2D(uSampler, vTextureCoord);
            lowp float intensity    = (color.r + color.g + color.b) / 3.0;
            intensity               = (uRange.x * (intensity - 0.5)) + 0.5 + uRange.y;
            gl_FragColor            = vec4(intensity, intensity, intensity, 1.0);
        }
        `
        function createIntensityShader(context, texture, flip, range) {
            const shaderProgram     = initShaderProgram(context, shaderSourceIntensityVertex, shaderSourceIntensityFragment)
            const aVertexPosition   = context.getAttribLocation(shaderProgram, 'aVertexPosition')
            const aTextureCoord     = context.getAttribLocation(shaderProgram, 'aTextureCoord')
            const uFlip             = context.getUniformLocation(shaderProgram, 'uFlip')
            const uRange            = context.getUniformLocation(shaderProgram, 'uRange')
            const uSampler          = context.getUniformLocation(shaderProgram, 'uSampler')
            context.useProgram(shaderProgram)
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.vertexAttribPointer(aVertexPosition, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aVertexPosition)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.vertexAttribPointer( aTextureCoord, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aTextureCoord)
            context.activeTexture(context.TEXTURE0)
            context.bindTexture(context.TEXTURE_2D, texture)
            context.uniform1i(uSampler, 0)
            return {
                program: shaderProgram,
                uniform: {
                    flip: uFlip,
                    range: uRange,
                },
                render(context, flip, range) {
                    context.useProgram(this.program)
                    context.uniform2iv(this.uniform.flip, flip)
                    context.uniform2fv(this.uniform.range, range)
                    context.drawArrays(context.TRIANGLES, 0, 6)
                }
            }
        }
    </script>
    <script>
        const shaderSourceGameboyVertex =
        `
        attribute lowp vec2 aVertexPosition;
        attribute lowp vec2 aTextureCoord;
        varying lowp vec2 vTextureCoord;
        void main() {
            gl_Position         = vec4(aVertexPosition.x, 0.0 - aVertexPosition.y, 0.0, 1.0);
            vTextureCoord       = aTextureCoord;
        }
        `
        const shaderSourceGameboyFragment =
        `
        varying lowp vec2 vTextureCoord;
        uniform sampler2D uSampler;
        void main() {
            bool evenColumn     = (mod(floor(gl_FragCoord.x), 2.0) == 0.0);
            bool evenRow        = (mod(floor(gl_FragCoord.y), 2.0) == 0.0);
            lowp vec4 color     = texture2D(uSampler, vTextureCoord);
            lowp float pixel    = color.r * 4.0;
            lowp float decimal  = mod(pixel, 1.0);
            if (decimal > 0.25 && .75 < decimal) {
                if (evenColumn) {
                    if (evenRow) {
                        pixel = ceil(pixel);
                    } else {
                        pixel = floor(pixel);
                    }
                } else {
                    if (evenRow) {
                        pixel = floor(pixel);
                    } else {
                        pixel = ceil(pixel);
                    }
                }
            } else {
                pixel = floor(pixel + 0.5);
            }
            pixel /= 4.0;
            
            gl_FragColor    = vec4(pixel, pixel + .05, pixel, 1.0);
        }
        `
        function createGameboyShader(context, texture) {
            const shaderProgram     = initShaderProgram(context, shaderSourceGameboyVertex, shaderSourceGameboyFragment)
            const aVertexPosition   = context.getAttribLocation(shaderProgram, 'aVertexPosition')
            const aTextureCoord     = context.getAttribLocation(shaderProgram, 'aTextureCoord')
            const uSampler          = context.getUniformLocation(shaderProgram, 'uSampler')
            context.useProgram(shaderProgram)
            context.bindBuffer(context.ARRAY_BUFFER, screenBuffer)
            context.vertexAttribPointer(aVertexPosition, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aVertexPosition)
            context.bindBuffer(context.ARRAY_BUFFER, screenUVBuffer)
            context.vertexAttribPointer(aTextureCoord, 2, context.FLOAT, false, 0, 0)
            context.enableVertexAttribArray(aTextureCoord)
            context.activeTexture(context.TEXTURE0)
            context.bindTexture(context.TEXTURE_2D, texture)
            context.uniform1i(uSampler, 0)
            return {
                program: shaderProgram,
                render(context) {
                    context.useProgram(this.program)
                    context.drawArrays(context.TRIANGLES, 0, 6)
                }
            }
        }
    </script>
    <script>
        const electron              = require('electron')
        const print                 = electron.remote.require('./index.js').print
        
        const video                 = document.createElement('video')
        const canvas                = document.getElementById('canvas')
        const context               = canvas.getContext('webgl')
        const config                = document.getElementById('config')
        const configSource          = document.getElementById('config_source')
        const configContrast        = document.getElementById('config_contrast')
        const configBrightness      = document.getElementById('config_brightness')
        const configDimensionWidth  = document.getElementById('config_dimension_width')
        const configDimensionHeight = document.getElementById('config_dimension_height')
        const configFlipHorizontal  = document.getElementById('config_flip_horizontal')
        const configFlipVertical    = document.getElementById('config_flip_vertical')

        video.loop = true
        video.muted = true
        video.autoplay = true

        let contrast
        let brightness
        let flipHorizontal
        let flipVertical

        initBuffers(context)
        const texture           = initTexture(context)
        const shaderIntensity   = createIntensityShader(context, texture)
        const shaderGameboy     = createGameboyShader(context, texture)

        function cameraFeed() {
            video.toggleAttribute('src', false)
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
            .then(stream=>{
                video.srcObject = stream
                video.play()
            })
            .catch(err=>console.error(err))
        }

        function sourceFeed() {
            video.src = configSource.value
            video.play()
        }

        function configRefresh() {
            contrast        = configContrast.value
            brightness      = configBrightness.value
            flipHorizontal  = configFlipHorizontal.checked
            flipVertical    = configFlipVertical.checked
            canvas.width    = configDimensionWidth.value
            canvas.height   = configDimensionHeight.value
        }
        configRefresh()

        function draw(timestamp) {
            updateTexture(context, texture, video)
            context.clearColor(1.0, 0.0, 0.0, 1.0)
            context.clear(context.COLOR_BUFFER_BIT | context.COLOR_BUFFER_BIT)
            context.viewport(0, 0, context.canvas.width, context.canvas.height)
            shaderIntensity.render(context, [flipHorizontal, flipVertical], [contrast, brightness])
            if (isTakingPicture) {
                takePicture()
                isTakingPicture = false
            }
            updateTexture(context, texture, canvas)
            shaderGameboy.render(context)
            requestAnimationFrame(draw)
        }
        
        const filter = {
            matrix:[
                0,     128,    
                192,    64,],
            dimension: 2
        }
        function takePicture() {
            const canvasPicture     = document.createElement('canvas')
            canvasPicture.width     = canvas.width
            canvasPicture.height    = canvas.height
            const contextPicture    = canvasPicture.getContext('2d')
            contextPicture.drawImage(canvas, 0, 0, canvas.width, canvas.height)
            let imageData   = contextPicture.getImageData(0, 0, canvas.width, canvas.height)
            let data        = imageData.data
            for (let i = 0; i < data.length; i+=4) {
                let pixelCount = i / 4
                let row = (Math.floor(pixelCount / canvas.width) % filter.dimension) * filter.dimension
                if (data[i] > filter.matrix[(pixelCount % filter.dimension) + row]) {
                    data[i] = data[i + 1]  = data[i + 2] = 255
                } else {
                    data[i] = data[i + 1]  = data[i + 2] = 0
                }
            }
            contextPicture.putImageData(imageData, 0, 0)
            canvasPicture.toBlob(blob=>{
                blob
                .arrayBuffer()
                .then(buffer=>print(buffer))
            }, 'image/png')
        }
        
        let isTakingPicture = false
        window.addEventListener('keyup',e=>{
            console.log(e.key)
            switch (e.key) {
                case 'q':
                    config.toggleAttribute('hidden')
                break
                case 'x':
                    window.close()
                break
                case ' ':
                    if (!isTakingPicture) isTakingPicture = true
                break
            }
        }, true)

        requestAnimationFrame(draw)
    </script>
</body>
</html>
